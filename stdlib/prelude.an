/*
        prelude.an
    Standard functions and datatypes pre-imported
    into every Ante source file.
*/

//C functions
printf (ref c8) ... -> i32
puts (ref c8) -> i32
putchar c8 -> unit
getchar unit -> c8
exit i32 -> 'never_returns
malloc usz -> ref 'a
calloc usz usz -> ref 'a
realloc (ref 'a) usz -> ref 'a
free (ref 'a) -> unit
memcpy (dest:ref 'a) (src:ref 'b) usz -> ref 'a //dest
system (ref c8) -> i32
strlen (ref c8) -> usz

//C stdio
type File = (f:ref unit)
type FilePos = (f:ref unit)

type InFile = f:File
type OutFile = f:File

fopen (name:ref c8) (mode:ref c8) -> File
fclose File -> unit

fputs (ref c8) OutFile -> unit
fputc c8 OutFile -> unit
fgetc InFile -> c8
fgets (ref c8) i32 InFile -> ref c8
ungetc c8 InFile -> i32

fgetpos File FilePos -> unit
ftell File -> i64
fsetpos File FilePos -> unit
fseek File i64 i32 -> unit

feof InFile -> bool
ferror File -> bool



//Ante datatypes
type Str =
    cStr: (ref c8)
    len: usz

type Maybe 't =
   | Some 't
   | None

type Type 't = none:unit


trait Empty 't
    empty (Type 't) -> 't


impl Eq (Maybe 'e) given Eq 'e
    (==) l r =
        match l with
        | Some lv ->
            match r with
            | Some rv -> lv == rv
            | None -> false
        | None ->
            match r with
            | Some rv -> false
            | None -> true


impl To Str (Maybe 'm) given To Str 'm
    to _ maybe =
        match maybe with
        | Some val -> to Str val
        | None -> "None"


//Compile-time functions
module Ante
    //prints type and value (llvm dump) of variable while compiling
    ante debug 't -> unit

    //returns the size of a type in Bytes.  Accepts types or values as an argument
    ante sizeof 't -> usz

    //return the type of an expression.  Note: Type is an ante type (compile-time only)
    ante typeof 't -> Type 't

    //Issue an error message during compile-time and stop compiling the current function
    ante error (ref c8) -> 'never_returns

    //dumps llvm-ir to stdout
    ante emit_ir unit -> unit

    //useful in the repl to redefine functions
    ante forget (name: ref c8) -> unit


trait Add 'n
    (+) 'n 'n -> 'n

trait Sub 'n
    (-) 'n 'n -> 'n

trait Mul 'n
    (*) 'n 'n -> 'n

trait Div 'n
    (/) 'n 'n -> 'n

trait Mod 'n
    (%) 'n 'n -> 'n

trait Pow 'n
    (^) 'n 'n -> 'n

trait Cmp 'n
    (<) 'n 'n -> bool
    (>) 'n 'n -> bool
    //(<=) l:'n r:'n = not (l > r)
    //(>=) l:'n r:'n = not (l < r)

trait Eq 't
    (==) 't 't -> bool
    // (!=) l r = not (l == r)

trait Is 't
    (is) 't 't -> bool

trait Append 't
    (++) 't 't -> 't

trait Extract 'col 'index
    type ExtractElem
    (#) 'col 'index -> ExtractElem

trait Insert 'col 'index 'elem
    // temporary until functions with the same name and
    // a differing number of parameters can be declared.
    insert (mut 'col) 'index 'elem -> unit

trait In 'elem 'col
    (in) 'elem 'col -> bool

trait Range 'l 'r
    type RangeResult
    (..) 'l 'r -> RangeResult

trait Deref 't
    type DerefResult
    (@) 't -> DerefResult

trait Neg 't
    neg 't -> 't

trait Not 't
    (not) 't -> 't


trait Print 't
    printne 't -> unit

print x =
    printne x
    puts "".cStr


trait To 't /*from*/ 'u
    to (Type 't) 'u -> 't


//numerical print functions
impl Print i8
    printne x = printf ("%hhd".cStr) x

impl Print i16
    printne x = printf ("%hd".cStr) x

impl Print i32
    printne x = printf ("%d".cStr) x

impl Print i64
    printne x = printf ("%ld".cStr) x

impl Print isz
    printne x = printf ("%zi".cStr) x

//unsigned
impl Print u8
    printne x = printf ("%hhu".cStr) x

impl Print u16
    printne x = printf ("%hu".cStr) x

impl Print u32
    printne x = printf ("%u".cStr) x

impl Print u64
    printne x = printf ("%lu".cStr) x

impl Print usz
    printne x = printf ("%zu".cStr) x

//floats
impl Print f16
    printne x = printf ("%.2f".cStr) (f64 x)

impl Print f32
    printne x = printf ("%f".cStr) (f64 x)

impl Print f64
    printne x = printf ("%.14f".cStr) x

//char
impl Print c8
    printne x = printf ("%c".cStr) x

//bool
impl Print bool
    printne b =
        if b then printf ("true".cStr)
        else printf ("false".cStr)

//c-string
impl Print (ref c8)
    printne s = printf ("%s".cStr) s


impl Print Str
    printne s = printne (s.cStr)


impl To (ref c8) Str
    to _ s = s.cStr


module Str
    reverse s:Str -> Str =
        buf = mut malloc (s.len + 1usz)

        i = mut 0usz
        while i < s.len do
            buf#i := s.cStr#(s.len - i - 1usz)
            i += 1usz

        buf#i := '\0'
        Str(buf, i)


impl To Str i64
    to _ i =
        if i == 0i64 then return "0"
        len = mut 0usz
        buf = mut malloc 21usz
        buf#20usz := '\0'

        x = mut i
        isNeg = i < 0i64 and ((x *= -1i64); true)

        while x != 0i64 do
            len += 1usz
            buf#(20usz - len) := '0' + c8(x % 10i64)
            x /= 10i64

        if isNeg then
            len += 1usz
            buf#(20usz - len) := '-'

        offset = usz buf + (20usz - len)
        Str(ref c8 offset, len)


impl To Str u64
    to _ i =
        if i == 0u64 then return "0"
        len = mut 0usz
        buf = mut malloc 21usz
        buf#20usz := '\0'

        x = mut i
        while x != 0u64 do
            len += 1usz
            buf#(20usz - len) := '0' + c8(x % 10u64)
            x /= 10u64

        offset = usz buf + (20usz - len)
        Str(ref c8 offset, len)


// convert all other numeric types to strings by widening first
impl To Str i8
    to _ x = i64 x as Str

impl To Str i16
    to _ x = i64 x as Str

impl To Str i32
    to _ x = i64 x as Str

impl To Str isz
    to _ x = i64 x as Str

impl To Str u8
    to _ x = u64 x as Str

impl To Str u16
    to _ x = u64 x as Str

impl To Str u32
    to _ x = u64 x as Str

impl To Str usz
    to _ x = u64 x as Str


module U64
    parse s:Str -> Maybe u64 =
        i = mut 0usz
        sum = mut 0u64

        while s.cStr#i != '\0' do
            c = s.cStr#i
            if c >= '0' and c <= '9' then
                sum *= 10u64
                sum += u64(c - '0')
                i += 1usz
                None
            else
                return None

        Some sum

module I64
    parse s:Str -> Maybe i64 =
        i = mut 0usz
        sum = mut 0i64
        isNeg =
            if s.len == 0usz or s.cStr#0usz == '-' then false
            else ((i += 1usz); true)

        while s.cStr#i != '\0' do
            c = s.cStr#i
            if c >= '0' and c <= '9' then
                sum *= 10i64
                sum += i64(c - '0')
                i += 1usz
                None
            else
                return None

        Some (if isNeg then -1i64 * sum else sum)


impl Eq (ref 't) given Eq 't
    (==) l r = @l == @r


//For-loops work over any range that is Iterable
trait Iterable 'i
    into_iter 'i -> 'it given Iterator 'it

trait Iterator 'i
    type IteratorElem
    has_next 'i -> bool
    cur_elem 'i -> IteratorElem
    advance 'i -> 'i

type LazyRange = start:i32 end:i32 step:i32

//returns true if a is in the range r
impl In i32 LazyRange
    (in) a r =
        if r.step == 1 then
            r.start <= a and a < r.end
        else
            a_adj = a % r.step
            s_adj = r.start % r.step

            a_adj == s_adj and r.start <= a and a < r.end

//creates an end-exclusive range
impl Range i32 i32
    type RangeResult = r:LazyRange
    (..) start end =
        LazyRange(start, end, 1)

//Takes a tuple of the first two integers and calculates the step by their difference
impl Range (i32,i32) i32
    type RangeResult = f:LazyRange
    (..) first_two end =
        LazyRange(first_two#0usz, end, first_two#1usz - first_two#0usz)

impl Iterator LazyRange
    type IteratorElem = e:i32
    cur_elem r = r.start
    advance r = LazyRange(r.start + r.step, r.end, r.step)
    has_next r = (r.step > 0 and r.start < r.end) or (r.step < 0 and r.start > r.end)


//Iterating through an InFile iterates through each line
impl Iterator InFile
    type IteratorElem = s:Str
    has_next f = not feof f
    cur_elem f = InFile.next_line f
    advance f = f


module OutFile
    write f:OutFile s:Str =
        fputs (s.cStr) f

module Str
    print s:Str =
        puts s.cStr

impl To Str (ref c8)
    to t cStr = Str(cStr, usz strlen cStr)

impl Eq Str
    (==) l r =
        if l.len != r.len then
            return false

        for i in 0 .. i32 l.len do
            if l.cStr#i != r.cStr#i then
                return false
        true

impl Is Str
    (is) l r = l.cStr is r.cStr


impl Append Str
    (++) s1 s2 =
        if s1.len == 0usz then return s2
        if s2.len == 0usz then return s1

        len = s1.len + s2.len
        buf = mut malloc (len+1usz)

        memcpy buf (s1.cStr) s1.len

        buf_offset = (usz buf + s1.len) as ref unit
        memcpy buf_offset (s2.cStr) (s2.len+1usz) //copy terminating null too

        Str(buf, len)

impl Extract Str usz
    type ExtractElem = c:c8
    (#) s index = s.cStr#index


impl Insert Str usz c8
    insert str index char =
        str.cStr#index := char

impl To InFile Str
    to t fName = InFile fopen (fName.cStr) ("r".cStr)


impl To OutFile Str
    to t fName = OutFile fopen (fName.cStr) ("w".cStr)


module InFile
    next_line f:InFile -> Str =
        if feof f then return ""
        eof = c8 255

        len = mut 0usz
        cap = mut 64usz
        cstr = mut malloc cap

        while
            c = fgetc f

            if c == eof then break

            //Flag feof if eof occurs after terminating newline
            if c == '\n' then
                peek = fgetc f
                if peek != eof then ungetc peek f
                break

            if len+1usz >= cap then
                cap *= 2usz
                cstr := realloc cstr cap

            cstr#len := c
            len += 1usz
            true
        do ()

        cstr#len := '\0'
        Str(cstr, len)


//print a message then return user input
input msg -> Str =
    len = mut 0usz
    cstr = mut ref c8 0

    printne msg

    while
        c = getchar ()
        if len % 32usz == 0usz then
            cstr := realloc cstr (len+32usz)

        cstr#len := c
        len += 1usz
        c != '\n'
    do ()

    len -= 1usz
    cstr#len := '\0'
    Str(cstr, len)
