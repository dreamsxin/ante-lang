/*
        prelude.an
    Standard functions and datatypes pre-imported
    into every Ante source file.
*/

//C functions
fun printf: ref c8 fmt, ... -> i32
fun puts: ref c8 str -> i32
fun putchar: c8 char
fun getchar: -> c8
fun exit: i32 status
fun malloc: usz size -> ref void
fun calloc: usz num size -> ref void
fun realloc: ref void ptr, usz size -> ref void
fun free: ref void mem
fun memcpy: ref void dest src, usz bytes -> ref void /*dest*/
fun system: ref c8 cmd -> i32
fun strlen: ref c8 str -> usz

//C stdio
type File = ref void
type FilePos = ref void

type InFile = File
type OutFile = File

fun fopen: ref c8 fName, ref c8 mode -> File
fun fclose: File file

fun fputs: ref c8 str, OutFile file
fun fputc: c8 char, OutFile file
fun fgetc: InFile file -> c8
fun fgets: ref c8 str, i32 numBytes, InFile file -> ref c8
fun ungetc: c8 c, InFile file -> i32

fun fgetpos: File f, FilePos fp
fun ftell: File f -> i64
fun fsetpos: File f, FilePos fp
fun fseek: File f, i64 offset, i32 origin

fun feof: InFile f -> bool
fun ferror: File f -> bool



//Ante datatypes
type Str = ref c8 cStr, usz len

type Maybe 't =
   | Some 't
   | None

type Type 't = void


trait Empty 't
    fun empty: Type 't ty -> 't


impl Eq (Maybe (Eq 'e))
    fun (=): Maybe 'e l r -> bool
        match l with
        | Some lv ->
            match r with
            | Some rv -> lv = rv
            | None -> false
        | None ->
            match r with
            | Some rv -> false
            | None -> true



impl To Str (Maybe (To Str 'm))
    fun to: Type Str _, Maybe 'm l -> Str
        match l with
        | Some val -> "tmp" //Str val
        | None -> "None"


//Compile-time functions
module Ante
    //prints type and value (llvm dump) of variable while compiling
    ante fun debug: 't t

    //returns the size of a type in Bytes.  Accepts types or values as an argument
    ante fun sizeof: 't t -> usz

    //return the type of an expression.  Note: Type is an ante type (compile-time only)
    ante fun typeof: 't t -> Type 't

    //Note: error never returns
    ante fun error: ref c8 msg

    //dumps llvm-ir to stdout
    ante fun emit_ir:

    //useful in the repl to redefine functions
    ante fun forget: ref c8 function_name


trait Add 'n
    fun (+): 'n l r -> 'n

trait Sub 'n
    fun (-): 'n l r -> 'n

trait Mul 'n
    fun (*): 'n l r -> 'n

trait Div 'n
    fun (/): 'n l r -> 'n

trait Mod 'n
    fun (%): 'n l r -> 'n

trait Pow 'n
    fun (^): 'n l r -> 'n

trait Cmp 'n
    fun (<): 'n l r -> bool
    fun (>): 'n l r -> bool
    // fun(<=): 'n l r = not (n > r)
    // fun(>=): 'n l r = not (n < r)

trait Eq 't
    fun (=): 't l r -> bool
    // fun (!=): 't l r = not (l = r)

trait Is 't
    fun (is): 't l r -> bool

trait Append 't
    fun (++): 't l r -> 't

trait Extract 'col 'index
    type Elem
    fun (#): 'col collection, 'index index -> Elem

trait Insert 'col 'index 'elem
    // temporary until functions with the same name and
    // a differing number of parameters can be declared.
    fun insert: mut 'col collection, 'index idx, 'elem elem

trait In 'elem 'col
    fun (in): 'elem elem, 'col collection -> bool

trait Range 't
    type Result
    fun (..): 't l r -> Result

trait Deref 't
    type Result
    fun (@): 't t -> Result

trait Neg 't
    fun neg: 't t -> 't

trait Not 't
    fun (not): 't t -> 't


trait Print 't
    fun printne: 't x

fun print: x
    printne x
    puts "".cStr


trait To 't /*from*/ 'u
    fun to: Type 't to, 'u from -> 't


//intrinsics for numeric types
impl Cmp usz
    fun (<): a, b = true
    fun (>): a, b = true

impl Cmp i32
    fun (<): a, b = true
    fun (>): a, b = true

impl Add i32
    fun (+): a, b = a + b

impl Sub i32
    fun (-): a, b = a - b

impl Mul i32
    fun (*): a, b = a * b

impl Add usz
    fun (+): a, b = a + b

impl Sub usz
    fun (-): a, b = a - b

impl Extract (ref 't) 't
    fun (#): c, i = c#i


//numerical print functions
impl Print i8
    fun printne: i8 x
        printf "%hhd".cStr x

impl Print i16
    fun printne: i16 x
        printf "%hd".cStr x

impl Print i32
    fun printne: i32 x
        printf "%d".cStr x

impl Print i64
    fun printne: i64 x
        printf "%ld".cStr x

impl Print isz
    fun printne: isz x
        printf "%zi".cStr x

//unsigned
impl Print u8
    fun printne: u8 x
        printf "%hhu".cStr x

impl Print u16
    fun printne: u16 x
        printf "%hu".cStr x

impl Print u32
    fun printne: u32 x
        printf "%u".cStr x

impl Print u64
    fun printne: u64 x
        printf "%lu".cStr x

impl Print usz
    fun printne: usz x
        printf "%zu".cStr x

//floats
impl Print f16
    fun printne: f16 x
        printf "%.2f".cStr (f64 x)

impl Print f32
    fun printne: f32 x
        printf "%f".cStr (f64 x)

impl Print f64
    fun printne: f64 x
        printf "%.14f".cStr x

//char
impl Print c8
    fun printne: c8 x
        printf "%c".cStr x

//bool
impl Print bool
    fun printne: bool b
        if b then printf "true".cStr
        else printf "false".cStr

//c-string
impl Print (ref c8)
    fun printne: ref c8 s
        printf "%s".cStr s


impl Print Str
    fun printne: Str s
        printne s.cStr


impl To (ref c8) Str
    fun to: _, Str s = s.cStr


module Str
    fun reverse: Str s -> Str
        mut buf = ref c8 malloc (s.len + 1usz)

        mut i = 0usz
        while i < s.len do
            buf#i := s.cStr#(s.len - i - 1usz)
            i += 1usz

        buf#i := '\0'
        Str(buf, i)


impl To Str i64
    fun to: _, i64 i -> Str
        if i = 0i64 then return "0"
        mut len = 0usz
        mut buf = ref c8 malloc 21usz
        buf#20usz := '\0'

        mut x = i
        let isNeg = i < 0i64 and ((x *= -1i64); true)

        while x != 0i64 do
            len += 1usz
            buf#(20usz - len) := '0' + c8(x % 10i64)
            x /= 10i64

        if isNeg then
            len += 1usz
            buf#(20usz - len) := '-'

        let offset = usz buf + (20usz - len)
        Str(ref c8 offset, len)


impl To Str u64
    fun to: _, u64 i -> Str
        if i = 0u64 then return "0"
        mut len = 0usz
        mut buf = ref c8 malloc 21usz
        buf#20usz := '\0'

        mut x = i
        while x != 0u64 do
            len += 1usz
            buf#(20usz - len) := '0' + c8(x % 10u64)
            x /= 10u64

        let offset = usz buf + (20usz - len)
        Str(ref c8 offset, len)


// convert all other numeric types to strings by widening first
// impl To i8 Str
//     fun to: _, i8 x = to Str (i64 x)
//
// impl To i16 Str
//     fun to: _, i16 x = to Str (i64 x)
//
// impl To i32 Str
//     fun to: _, i32 x = to Str (i64 x)
//
// impl To isz Str
//     fun to: _, isz x = to Str (i64 x)
//
// impl To u8 Str
//     fun to: _, u8 x = to Str (u64 x)
//
// impl To u16 Str
//     fun to: _, u16 x = to Str (u64 x)
//
// impl To u32 Str
//     fun to: _, u32 x = to Str (u64 x)
//
// impl To usz Str
//     fun to: _, usz x = to Str (u64 x)


// module u64
//     fun parse: Str s -> Maybe u64
//         mut i = 0
//         mut sum = 0u64
//
//         while s#i != '\0' do
//             let c = s#i
//             if c >= '0' and c <= '9' then
//                 sum *= 10
//                 sum += c - '0'
//                 i += 1
//             else
//                 return None
//
//         Some sum
//
// module i64
//     fun parse: Str s -> Maybe i64
//         mut i = 0
//         mut sum = 0i64
//         let isNeg =
//             if s.len != 0 and s#0 = '-' then
//                 i += 1
//                 true
//             else false
//
//         while s#i != '\0' do
//             let c = s#i
//             if c >= '0' and c <= '9' then
//                 sum *= 10
//                 sum += c - '0'
//                 i += 1
//             else
//                 return None
//
//         Some (if isNeg then -1 * sum else sum)


//Pointer Equivalence
impl Eq (ref (Eq 't))
    fun (=): ref 't l r =
        @l = @r


//For-loops work over any range that is Iterable
trait Iterable 'i
    fun into_iter: 'i i -> Iterator

trait Iterator 'i
    type Elem
    fun next: 'i i -> 'i
    fun unwrap: 'i i -> Elem
    fun has_next: 'i i -> bool


// type LazyRange = i32 start end step
//
// //returns true if a is in the range r
// impl In LazyRange i32
//     fun (in): i32 a, LazyRange r -> bool
//         if r.step = 1 then
//             r.start <= a and a < r.end
//         else
//             let a_adj = a % r.step
//             let s_adj = r.start % r.step
//
//             a_adj = s_adj and r.start <= a and a < r.end

//creates an end-exclusive range
// impl Range i32
//     type Result = LazyRange
//     fun (..): i32 start end -> LazyRange
//         LazyRange(start, end, 1)
//
// //Takes a tuple of the first two integers and calculates the step by their difference
// impl Range (i32,i32) i32
//     type Result = LazyRange
//     fun (..): i32,i32 first_two, i32 end -> LazyRange
//         LazyRange(first_two#0, end, first_two#1 - first_two#0)
//
// impl Iterator LazyRange
//     type Elem = i32
//
//     fun next: LazyRange r -> LazyRange
//         LazyRange(r.start+r.step, r.end, r.step)
//
//     fun unwrap: LazyRange r =
//         r.start
//
//     fun has_next: LazyRange r =
//         if r.step > 0 then
//             r.start < r.end
//         elif r.step < 0 then
//             r.start > r.end
//         else false //step = 0


//Iterating through an InFile iterates through each line
// impl Iterator InFile
//     type Elem = Str
//
//     fun has_next: InFile f = not feof f
//
//     fun next: InFile f = f
//
//     fun unwrap: InFile f = InFile.next_line f


module OutFile
    fun write: OutFile f, Str s
        fputs (s.cStr) f

module Str
    fun print: Str s
        puts s.cStr

impl To Str (ref c8)
    fun to: t, ref c8 cStr -> Str
        Str(cStr, usz strlen cStr)

impl Eq Str
    fun (=): Str l r -> bool
        if l.len != r.len then
            return false

        for i in 0 .. i32 l.len do
            if l.cStr#i != r.cStr#i then
                return false
        true

impl Is Str
    fun (is): Str l r = l.cStr is r.cStr


// impl Append Str
//     fun (++): Str s1 s2 -> Str
//         if s1.len = 0 then return s2
//         if s2.len = 0 then return s1
//
//         let len = s1.len + s2.len
//         mut buf = malloc (len+1)
//
//         memcpy buf (ref void s1.cStr) s1.len
//
//         mut buf_offset = (usz buf + s1.len) as ref void
//         memcpy buf_offset (ref void s2.cStr) (s2.len+1) //copy terminating null too
//
//         Str(ref c8 buf, len)
//
// impl Extract Str i32
//     type Elem = c8
//
//     fun (#): Str s, i32 index = s.cStr#index
//
//     fun (#): Str s, i32 i, c8 c
//         s.cStr#i := c
//
//
// impl To InFile Str
//     fun to: t, Str fName -> InFile
//         InFile fopen (fName.cStr) "r".cStr
//
//
// impl To OutFile Str
//     fun to: t, Str fName -> OutFile
//         OutFile fopen (fName.cStr) "w".cStr
//
//
// module InFile
//     fun next_line: InFile f -> Str
//         if feof f then return ""
//         let eof = c8 255
//
//         mut len = 0usz
//         mut cap = 64usz
//         mut cstr = ref c8 malloc cap
//
//         while
//             let c = fgetc f
//
//             if c = eof then break
//
//             //Flag feof if eof occurs after terminating newline
//             if c = '\n' then
//                 let peek = fgetc f
//                 if peek != eof then ungetc peek f
//                 break
//
//             if len+1 >= cap then
//                 cap *= 2
//                 cstr := ref c8 realloc (ref void cstr) cap
//
//             cstr#len := c
//             len += 1
//             true
//         do ()
//
//         cstr#len := '\0'
//         Str(cstr, len)
//
//
// //print a message then return user input
// fun input: ref c8 msg -> Str
//     mut len = 0usz
//     mut cstr = ref c8 0
//
//     printne msg
//
//     while
//         let c = getchar ()
//         if len % 32 = 0 then
//             cstr := ref c8 realloc (ref void cstr) (len+32)
//
//         cstr#len := c
//         len += 1
//         c != '\n'
//     do ()
//
//     len -= 1
//     cstr#len := '\0'
//     Str(cstr, len)
